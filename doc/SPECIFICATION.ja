Demi 言語仕様


<字句構造>

* コメント

//から改行までと/*から*/まではコメントと見做されます。

例:

// コメント

/* 複数行の
           コメント */

* 予約語

以下に挙げるものは予約語です。

break catch class continue def else elsif end exception false
finally for if in import instanceof module new null return this
throw true try while

ただし def, elsif, end, exception, in, module についてはメンバ
アクセスに用いることができます。

例:

in = 3       => NG
System::in   => OK


<プログラム>

Demiのプログラムはセミコロンで区切られた式の集りです。


<式>

例:

true
(1 + 2) * 3
foo()
if test: ok else: ng end

式は括弧によりグルーピングすることができます。


* 文字列リテラル

例:

"abcdefg"

文字列はダブルクウォートで囲まれます。


* 文字リテラル

例:

'a'

文字はシングルクウォートで囲まれます。


* 数値リテラル

例:

123     10進整数
0xca    16進整数
045     8進整数
123.45  浮動小数点数

整数リテラルはサイズによって、Integer/Long/BigIntegerのうち適切な
クラスのインスタンスに変換されます。同じように浮動小数点数もFloat
/Double/BigDecimalのインスタンスになります。


* 真偽値リテラル

true
false


* null

null


* シンボル

#識別子

例:

#abc
#hoge

同じ名前のシンボルは常に同一のオブジェクトです。
関数やモジュールの名前はシンボルで管理されています。


* 配列式

#( 式, ... )

配列(java.lang.Object[])を生成します。

例:

#("abc", 123, 'A')  //=> ("abc", 123, 'A')


* Vector式

#[ 式, ... ]

Vectorのインスタンスを生成します。

例:

#["abc", 123, 'A']  //=> [abc, 123, A]


* 連想配列式

{ 式 => 式, ... }

java.util.Hashtableのインスタンスを生成します。

例:

{"one" => 1, "two" => 2, "three" => 3} //=> {one=1, three=3, two=2}


* クラス式

class(クラス名)

クラス名に対応するJavaクラスを返します。

例:

class(java.util.Vector)


* 変数

Demiの変数にはモジュール変数とローカル変数の二種類があります。
変数は初期化が必ず必要です。

 [モジュール変数]

モジュールのスコープで初期化された変数はモジュール変数となります。
トップレベルで初期化された変数はglobalというモジュールのモジュー
ル変数となります。

モジュール名::変数名

とすることでモジュール定義の外から参照することができます。
グローバル変数は省略して，

::変数名

で参照できます。


 [ローカル変数]

関数のスコープで初期化された変数はローカル変数となります。
変数の有効範囲は関数内に限られます。


変数の検索順序は以下のようになっています。

スコープ   | 検索順序
-----------+---------------------------------------------
モジュール | モジュール変数 -> クラス名
-----------+---------------------------------------------
関数       | ローカル変数 -> モジュール変数 -> クラス名
-----------+---------------------------------------------


* 擬似変数

this

thisは現在のコンテキストで定義中のモジュールを返します。
トップレベルではglobalモジュールを返します。

exception

exceptionはtry式のcatch節で補足された例外を返します。


* 代入

変数 代入演算子 式
式 . 識別子 代入演算子 式
式 :: 識別子 代入演算子 式
:: 識別子 代入演算子 式
式 [ 式 ] 代入演算子 式

右辺を評価した値を左辺に代入します。

例:

foo = 1
foo.bar += "bar"
array[0] = 1.0

+=のように二項演算子=となっている場合，両辺の演算の結果を左辺に
代入します。

変数への代入は次のように解釈されます。

// グローバル変数(モジュールglobalのモジュール変数)への代入
a = "global";
module Foo:
    // モジュール変数への代入
    a = "module";
    def foo():
	// 関数のローカル変数への代入
	a = "function";
	func = [
	    // 関数のローカル変数への代入
	    a = "closure";
	];
	func();
    end;
end;


* 演算子式

例:

1 + 12
"abc" + "def"
#(1, 2, 3) + #(4, 5, 5)
1.2 * 4.89
20 % 6
1 > 2 || 3 > 2
"abc" == "abc"
"abc" === "abc"

==は同一性ではなく同値のチェック(多くの場合equalsメソッドの呼び出し)
を行います。同一性のチェックには===を用います。つまり"abc" == "abc"
はtrueですが、"abc" === "abc"はfalseとなります。

演算子はJavaで使用可能なものに加えて、inと..があります。

inは左辺の式を評価した値が右辺の式を評価した値(配列、文字列など)
に含まれている場合、true、そうでない場合、falseになります。

例:

'a' in "abc"     //=> true
3 in #(0, 1, 2)  //=> false
2 in 0..3        //=> true

右辺のオブジェクトがcontains(java.lang.Object)というメソッドを
持っている場合(java.util.Vectorなど)はそのメソッドを呼び出します。

..はRangeオブジェクトを生成します。
詳しくはfor式の説明を参照してください。


* 関数呼び出し

関数を呼び出します。
関数オブジェクト以外に対して関数呼び出しをすると、例外が発生します。

関数 '(' 式, ... ')'

例:

println("Hello, World!")


* オブジェクト生成式

Javaオブジェクトを生成します。

new (クラス式|変数) ( '(' 式, ... ')' | '[' 式 ']' )

例:

new class(java.lang.Object)()
new Vector(3)
new int[10]


* フィールド/モジュール変数アクセス

オブジェクトのフィールドやモジュール変数にアクセスします。

式 '.' Java識別子     インスタンスフィールド
式 '::' Java識別子    スタティックフィールド/モジュール変数

例:

foo.bar
System::in


* メソッド/モジュール関数呼び出し

オブジェクトに対してメソッド呼び出しをします。
モジュールの場合はモジュール関数を呼び出します。

式 '.' Java識別子 '(' 式, ... ')'   インスタンスメソッド
式 '::' Java識別子 '(' 式, ... ')'  スタティックメソッド/モジュール関数

例:

v.addElement("foo")
System::exit(0)


* 配列参照

式 '[' 式 ']'

配列の要素や、文字列、Vector、Hashtable などの要素を参照します。


* if式

if 条件式:
    式;...
[ elsif 条件式:
    式;... ]
[ else:
    式;... ]
end;

条件式が真の場合、そのブロックを実行します。Demiではnullと
false以外は偽と見做されます。条件式がすべて偽の場合、else
節が実行されます。
if式全体の値は最後に評価された式の値になります。


* while式

while 条件式:
    式;...
end;

例:

i = 1;
while i <= 10:
    println(i);
    i = i + 1;
end; 

条件式が真の間ループを繰り返します。


* for式

for 識別子 in (配列|java.util.Enumeration):
    式:
end;

例:

for i in #("foo", "bar", "baz"):
    println(i);
end;

各要素に対してループを繰り返します。
1から10まで繰り返す、といった場合はRangeオブジェクトを
用いて以下のようにします。

for i in 0..10:  // 0..10はRangeオブジェクト
    println(i);
end;


* break

break

ループを脱出します。


* continue

continue

ループの末尾にジャンプします。


* try式

try:
    式;...
( catch 例外クラス:
    式;... )*
[ finally:
    式;... ]
end;

try節で例外が発生した場合、例外に対応したcatch節が実行されます。
finally節は例外の発生如何に関わらず、必ず実行されます。


* throw

throw 式

例外を発生させます。
文字列をthrowに与えるとRuntimeExceptionを生成してthrowします。


* synchronized式

synchronized 式:
    式;...
end;

Javaのsynchronizedと同様に同期処理を行います。


* 関数定義

関数を定義します。関数定義のネストはできません。
return文がない場合は最後に評価された式の値が返り値になります。

def 識別子 '(' 識別子, ... ')':
    式;...
end

例:

def fact(n):
    if n == 0:
	return 1;
    else:
	return n * fact(n - 1);
    end;
end;

変数と関数は名前空間を共有します。

例:

def foo():
    println("foo");
end;
foo();          //=> foo
println(foo);   //=> <function foo at 0x80b3bf0>

引数にはデフォルト値を与えることができます。

例:

def foo(x = "default"):
    println(x);
end;

foo("bar");  //=> bar
foo();       //=> default

引数名に*を付けると、残りの引数を配列で受けとります。

def foo(first, second, *rest):
    p(rest);  // println(inspect(rest))と同じ
end;

foo(1, 2, 3, 4, 5);   //=> (3, 4, 5)


* return

return [ 式 ]

関数から脱出します。
式を指定すると、その値が関数の返り値になります。
式が指定されなかった場合の返り値はnullになります。


* クロージャ

'[' [ 識別子, ... ':' ] 式;... ']'

例:

foo = [ s: println(s) ]
foo("hello");           //=> hello

クロージャはコードブロックをコンテキスト(モジュールとローカル変数)
と共にオブジェクト化します。クロージャは無名の関数のように振舞います。

クロージャには以下のメソッドが定義されています。

* ifTrue(func)

例:

[1 > 0].ifTrue([ println("1 > 0 is true") ]);

* ifFalse(func)

例:

[1 > 0].ifFalse([ println("1 > 0 is false") ]);

* whileTrue(func)

例:

n = 0;
[n < 10].whileTrue([
    println(n);
    n++;
]);

* whileFalse(func)

例:

n = 0;
[n == 10].whileFalse([
    println(n);
    n++;
]);

* repeat(nth)

例:

[ println("hello") ].repeat(3);

* モジュール定義

モジュールを定義します。モジュール定義はネストすることが
できます。ただし、関数の中でモジュールを定義することはで
きません。

module 識別子:
    式;...
end

例:

module Foo:
    abc = "abc"
end

モジュールは変数/関数の名前空間を提供します。
モジュールは他のモジュールにインクルードすることができます。

例:

module Foo:
    bar = "abc";
end;

module Baz:
    include(Foo);

    def printBar():
	println(bar);
    end;
end;

Baz::printBar(); //=> abc

トップレベルはglobalという特別なモジュールのモジュール定義
になっています。


* import

Javaパッケージをインポートします。
インポートされたパッケージのクラスはクラス式を用いなくても、クラス名
で参照できるようになります。

import パッケージ名

例:

import java.text;   // java.text.*ではなくjava.text

NumberFormat::getInstance().format(10000);

クラスは最後にインポートされたパッケージから順に検索されます。
java.lang, java.io, java.utilについては最初からインポートされて
います。

